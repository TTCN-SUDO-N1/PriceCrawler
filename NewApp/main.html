<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8" />
    <title>Product Crawl Dashboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>

<body class="bg-gray-100 p-6">
    <div class="flex justify-between items-center mb-4">
        <h1 class="text-2xl font-bold text-gray-800">üìä B√°o c√°o S·∫£n ph·∫©m</h1>
        <div class="flex space-x-2">
            <button onclick="openAddProductModal()"
                class="bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700">‚ûï Th√™m s·∫£n ph·∫©m g·ªëc</button>
            <button onclick="refreshData()"
                class="bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600">üîÑ L√†m m·ªõi</button>
        </div>
    </div>

    <!-- Search and Filter Section -->
    <div class="bg-white rounded-lg p-4 mb-6 shadow-sm border">
        <div class="flex items-center space-x-4">
            <div class="flex-1">
                <label class="block text-sm font-medium text-gray-700 mb-2">üîç T√¨m ki·∫øm s·∫£n ph·∫©m</label>
                <input type="text" id="searchInput" 
                    class="w-full border border-gray-300 rounded px-3 py-2" 
                    placeholder="T√¨m theo t√™n s·∫£n ph·∫©m ho·∫∑c SKU..."
                    onkeyup="handleSearchKeyup(event)">
            </div>
            <div class="pt-6">
                <button onclick="searchProducts()" 
                    class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700">
                    üîç T√¨m ki·∫øm
                </button>
                <button onclick="clearSearch()" 
                    class="bg-gray-400 text-white px-4 py-2 rounded hover:bg-gray-500 ml-2">
                    ‚úñÔ∏è X√≥a
                </button>
            </div>
        </div>
    </div>

    <div class="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-6">
        <h2 class="text-lg font-semibold text-blue-700 mb-2">üìå H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng</h2>
        <ol class="list-decimal list-inside text-blue-600 ml-4 space-y-1">
            <li><strong>Th√™m s·∫£n ph·∫©m g·ªëc</strong> - ƒê√¢y l√† s·∫£n ph·∫©m c·ªßa b·∫°n m√† b·∫°n mu·ªën theo d√µi gi√°.</li>
            <li><strong>Th√™m s·∫£n ph·∫©m ƒë·ªëi th·ªß</strong> - Cho t·ª´ng s·∫£n ph·∫©m g·ªëc, th√™m link c·ªßa ƒë·ªëi th·ªß b√°n s·∫£n ph·∫©m
                t∆∞∆°ng t·ª±.</li>
            <li><strong>Ph√¢n t√≠ch gi√°</strong> - H·ªá th·ªëng s·∫Ω crawl th√¥ng tin gi√° c·∫£ v√† l∆∞u l·ªãch s·ª≠ ƒë·ªÉ so s√°nh.</li>
        </ol>
        <div class="mt-3 text-blue-700 font-medium">
            L∆∞u √Ω: M·ªói s·∫£n ph·∫©m ƒë·ªëi th·ªß ph·∫£i li√™n k·∫øt v·ªõi m·ªôt s·∫£n ph·∫©m g·ªëc. H·ªá th·ªëng kh√¥ng th·ªÉ ph√¢n t√≠ch s·∫£n ph·∫©m kh√¥ng
            c√≥ m·ªëi quan h·ªá v·ªõi nhau.
        </div>
    </div>

    <div id="productsContainer">
        <div class="text-center py-10 text-gray-500">Loading products...</div>
    </div>
    
    <!-- Pagination Controls -->
    <div id="paginationContainer" class="mt-4 flex justify-center items-center space-x-2 hidden">
        <button id="prevPageBtn" onclick="goToPage(currentPage - 1)" 
            class="px-3 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed">
            ‚Üê Tr∆∞·ªõc
        </button>
        <span id="pageInfo" class="px-4 py-2 text-gray-700"></span>
        <button id="nextPageBtn" onclick="goToPage(currentPage + 1)" 
            class="px-3 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed">
            Sau ‚Üí
        </button>
    </div>
    <div id="enemiesContainer" class="mt-8"></div>
    <div id="logsContainer" class="mt-8"></div>

    <!-- Add/Edit Product Modal -->
    <div id="addProductModal"
        class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50">
        <div class="bg-white rounded-lg p-6 w-full max-w-md shadow-xl">
            <h3 class="text-xl font-semibold mb-4" id="productModalTitle">Th√™m s·∫£n ph·∫©m g·ªëc</h3>
            <div class="space-y-3">
                <input type="hidden" id="editProductId" value="" />
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">T√™n s·∫£n ph·∫©m:</label>
                    <input type="text" id="productName"
                        class="w-full border border-gray-300 rounded px-3 py-2"
                        placeholder="iPhone 15 Pro" />
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">SKU:</label>
                    <input type="text" id="productSKU"
                        class="w-full border border-gray-300 rounded px-3 py-2"
                        placeholder="IP15P-256G" />
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">Link s·∫£n ph·∫©m:</label>
                    <div class="flex space-x-2">
                        <input type="text" id="productLink"
                            class="flex-1 border border-gray-300 rounded px-3 py-2"
                            placeholder="https://myshop.com/iphone15" 
                            onchange="onProductLinkChange(this.value)"
                            onpaste="setTimeout(() => onProductLinkChange(this.value), 100)" />
                        <button onclick="detectProductInfo()" type="button"
                            class="bg-blue-600 text-white px-3 py-2 rounded hover:bg-blue-700">üîç Crawl</button>
                    </div>
                    <div id="detectProductStatus" class="text-sm mt-1"></div>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">Gi√° g·ªëc:</label>
                    <input type="text" id="productOrigPrice"
                        class="w-full border border-gray-300 rounded px-3 py-2"
                        placeholder="32,000,000 VND" />
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">Gi√° hi·ªán t·∫°i:</label>
                    <input type="text" id="productCurPrice"
                        class="w-full border border-gray-300 rounded px-3 py-2"
                        placeholder="29,990,000 VND" />
                </div>
            </div>
            <div class="flex justify-end space-x-2 mt-6">
                <button onclick="closeAddProductModal()"
                    class="px-4 py-2 bg-gray-400 text-white rounded hover:bg-gray-500">H·ªßy</button>
                <button id="saveProductBtn" onclick="addOrEditProduct()"
                    class="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700">üíæ L∆∞u s·∫£n ph·∫©m</button>
            </div>
        </div>
    </div>

    <!-- Add/Edit Enemy Modal -->
    <div id="addEnemyModal"
        class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50">
        <div class="bg-white rounded-lg p-6 w-full max-w-md shadow-xl">
            <h3 class="text-xl font-semibold mb-4" id="enemyModalTitle">Th√™m s·∫£n ph·∫©m ƒë·ªëi th·ªß</h3>
            <input type="hidden" id="currentProductId" value="" />
            <input type="hidden" id="editEnemyId" value="" />
            <label class="block text-sm font-medium text-gray-700 mb-1">Ch·ªçn ƒë·ªëi th·ªß:</label>
            <select id="enemySelect" class="w-full border border-gray-300 rounded px-3 py-2 mb-4"></select>
            <div class="text-sm text-blue-600 mb-2">* ƒê·ªëi th·ªß s·∫Ω ƒë∆∞·ª£c t·ª± ƒë·ªông ph√°t hi·ªán d·ª±a v√†o domain c·ªßa link</div>
            <div id="autoDetectStatus" class="mb-2"></div>
            <label class="block text-sm font-medium text-gray-700 mb-1">Link s·∫£n ph·∫©m:</label>
            <input type="text" id="enemyLink"
                class="w-full border border-gray-300 rounded px-3 py-2 mb-4"
                placeholder="https://example.com/product123" 
                onchange="onEnemyLinkChange(this.value)"
                onpaste="setTimeout(() => onEnemyLinkChange(this.value), 100)" />
            <div class="flex justify-end space-x-2">
                <button onclick="closeEnemyModal()"
                    class="px-4 py-2 bg-gray-400 text-white rounded hover:bg-gray-500">H·ªßy</button>
                <button id="saveEnemyBtn" onclick="addOrEditEnemyLink()"
                    class="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700">üíæ L∆∞u ƒë·ªëi th·ªß</button>
            </div>
        </div>
    </div>

    <!-- Price History Modal -->
    <div id="priceHistoryModal"
        class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50">
        <div class="bg-white rounded-lg p-6 w-full max-w-4xl shadow-xl max-h-[90vh] overflow-y-auto">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-semibold" id="priceHistoryTitle">L·ªãch s·ª≠ gi√° s·∫£n ph·∫©m</h3>
                <button onclick="closePriceHistoryModal()" class="text-gray-500 hover:text-gray-700 text-2xl">√ó</button>
            </div>
            
            <div id="priceHistoryContent" class="space-y-4">
                <div class="text-center py-10 text-gray-500">Loading price history...</div>
            </div>
            
            <div class="flex justify-end mt-6">
                <button onclick="closePriceHistoryModal()"
                    class="px-4 py-2 bg-gray-400 text-white rounded hover:bg-gray-500">ƒê√≥ng</button>
            </div>
        </div>
    </div>

    <script>
        let currentProductId = null;
        let currentEnemyId = null;
        let selectedProductId = null;
        let selectedEnemyId = null;
        
        // Pagination and search state
        let currentPage = 1;
        let currentSearch = '';
        let totalPages = 1;
        let itemsPerPage = 10;
        let searchTimeout = null;

        document.addEventListener('DOMContentLoaded', function () {
            loadProducts();
        });

        function loadProducts(page = 1, search = '') {
            // Build query parameters
            const params = new URLSearchParams({
                page: page,
                per_page: itemsPerPage
            });
            
            if (search.trim()) {
                params.append('search', search.trim());
            }
            
            axios.get(`/api/product/?${params.toString()}`)
                .then(function (response) {
                    const data = response.data;
                    const products = data.products || [];
                    const pagination = data.pagination || {};
                    
                    // Update pagination state
                    currentPage = pagination.page || 1;
                    totalPages = pagination.pages || 1;
                    currentSearch = search;
                    
                    // Update products display
                    const container = document.getElementById('productsContainer');
                    if (products.length === 0) {
                        container.innerHTML = '<div class="text-center py-10 text-gray-500">Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m n√†o.</div>';
                        document.getElementById('paginationContainer').classList.add('hidden');
                        return;
                    }
                    
                    let html = `<table class="min-w-full text-sm text-left text-gray-700" id="productsTable">
                    <thead class="bg-gray-100">
                        <tr>
                            <th class="px-4 py-2">T√™n s·∫£n ph·∫©m</th>
                            <th>SKU</th>
                            <th>Link</th>
                            <th>Gi√° g·ªëc</th>
                            <th>Gi√° hi·ªán t·∫°i</th>
                            <th class="text-center">H√†nh ƒë·ªông</th>
                        </tr>
                    </thead>
                    <tbody>`;
                    products.forEach(product => {
                        html += `<tr class="cursor-pointer hover:bg-blue-50 product-row" data-product-id="${product.id}" onclick="selectProduct(${product.id}, this)">
                            <td class="px-4 py-2">${product.name}</td>
                            <td>${product.sku || ''}</td>
                            <td><a href="${product.link}" target="_blank" class="text-blue-600 hover:underline" onclick="event.stopPropagation()">${product.link || ''}</a></td>
                            <td>${product.org_price || ''}</td>
                            <td>${product.cur_price || ''}</td>
                            <td class="text-center space-x-1">
                                <button onclick="event.stopPropagation(); openEditProductModal(${product.id})" class="bg-yellow-400 text-white px-2 py-1 rounded">‚úèÔ∏è</button>
                                <button onclick="event.stopPropagation(); deleteProduct(${product.id})" class="bg-red-500 text-white px-2 py-1 rounded">üóëÔ∏è</button>
                                <button onclick="event.stopPropagation(); crawlProduct(${product.id})" class="bg-blue-600 text-white px-2 py-1 rounded">üîÑ Crawl</button>
                            </td>
                        </tr>
                        <tr class="enemy-container hidden" id="enemyContainer-${product.id}">
                            <td colspan="6" class="p-0">
                                <div class="bg-gray-50 p-4 border-l-4 border-blue-400">
                                    <div id="enemyContent-${product.id}" class="relative">
                                        <div class="text-center py-5">
                                            <span class="text-gray-500">Nh·∫•p ƒë·ªÉ t·∫£i th√¥ng tin ƒë·ªëi th·ªß</span>
                                        </div>
                                    </div>
                                </div>
                            </td>
                        </tr>`;
                    });
                    html += '</tbody></table>';
                    container.innerHTML = html;
                    
                    // Update pagination controls
                    updatePaginationControls(pagination);
                    
                    // Clear other containers
                    document.getElementById('enemiesContainer').innerHTML = '';
                    document.getElementById('logsContainer').innerHTML = '';
                })
                .catch(function (error) {
                    document.getElementById('productsContainer').innerHTML = '<div class="text-center py-10 text-red-500">L·ªói khi t·∫£i s·∫£n ph·∫©m. Vui l√≤ng th·ª≠ l·∫°i.</div>';
                });
        }

        // Search and pagination functions
        function handleSearchKeyup(event) {
            if (event.key === 'Enter') {
                searchProducts();
                return;
            }
            
            // Debounce search
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                searchProducts();
            }, 500);
        }

        function searchProducts() {
            const searchValue = document.getElementById('searchInput').value;
            currentPage = 1; // Reset to first page
            loadProducts(currentPage, searchValue);
        }

        function clearSearch() {
            document.getElementById('searchInput').value = '';
            currentPage = 1;
            currentSearch = '';
            loadProducts(currentPage, '');
        }

        function goToPage(page) {
            if (page < 1 || page > totalPages) return;
            loadProducts(page, currentSearch);
        }

        function updatePaginationControls(pagination) {
            const paginationContainer = document.getElementById('paginationContainer');
            const prevBtn = document.getElementById('prevPageBtn');
            const nextBtn = document.getElementById('nextPageBtn');
            const pageInfo = document.getElementById('pageInfo');

            if (pagination.pages <= 1) {
                paginationContainer.classList.add('hidden');
                return;
            }

            paginationContainer.classList.remove('hidden');
            
            // Update page info
            pageInfo.textContent = `Trang ${pagination.page} / ${pagination.pages} (${pagination.total} s·∫£n ph·∫©m)`;
            
            // Update button states
            prevBtn.disabled = !pagination.has_prev;
            nextBtn.disabled = !pagination.has_next;
            
            if (prevBtn.disabled) {
                prevBtn.classList.add('bg-gray-400', 'cursor-not-allowed');
                prevBtn.classList.remove('bg-blue-600', 'hover:bg-blue-700');
            } else {
                prevBtn.classList.remove('bg-gray-400', 'cursor-not-allowed');
                prevBtn.classList.add('bg-blue-600', 'hover:bg-blue-700');
            }
            
            if (nextBtn.disabled) {
                nextBtn.classList.add('bg-gray-400', 'cursor-not-allowed');
                nextBtn.classList.remove('bg-blue-600', 'hover:bg-blue-700');
            } else {
                nextBtn.classList.remove('bg-gray-400', 'cursor-not-allowed');
                nextBtn.classList.add('bg-blue-600', 'hover:bg-blue-700');
            }
        }

        // Price History functions
        function openPriceHistoryModal(productCrawlId) {
            document.getElementById('priceHistoryModal').classList.remove('hidden');
            document.getElementById('priceHistoryModal').classList.add('flex');
            document.getElementById('priceHistoryContent').innerHTML = '<div class="text-center py-10 text-gray-500">‚è≥ ƒêang t·∫£i l·ªãch s·ª≠ gi√°...</div>';
            
            loadPriceHistory(productCrawlId);
        }

        function closePriceHistoryModal() {
            document.getElementById('priceHistoryModal').classList.add('hidden');
            document.getElementById('priceHistoryModal').classList.remove('flex');
        }

        function loadPriceHistory(productCrawlId) {
            axios.get(`/api/product-crawl-logs/price-history/${productCrawlId}`)
                .then(function (response) {
                    const data = response.data;
                    const container = document.getElementById('priceHistoryContent');
                    
                    // Update title
                    document.getElementById('priceHistoryTitle').textContent = 
                        `L·ªãch s·ª≠ gi√° - ${data.product_crawl.product || 'S·∫£n ph·∫©m'} (${data.product_crawl.enemy || 'ƒê·ªëi th·ªß'})`;
                    
                    let html = '';
                    
                    // Show summary info
                    const chartData = data.chart_data;
                    if (chartData && chartData.total_records > 0) {
                        const trendColor = chartData.price_trend === 'increasing' ? 'text-red-600' : 
                                         chartData.price_trend === 'decreasing' ? 'text-green-600' : 'text-gray-600';
                        const trendIcon = chartData.price_trend === 'increasing' ? 'üìà' : 
                                        chartData.price_trend === 'decreasing' ? 'üìâ' : '‚û°Ô∏è';
                        
                        html += `
                        <div class="bg-gray-50 p-4 rounded-lg mb-4">
                            <div class="grid grid-cols-2 md:grid-cols-4 gap-4 text-center">
                                <div>
                                    <div class="text-sm text-gray-600">Gi√° m·ªõi nh·∫•t</div>
                                    <div class="text-lg font-bold">${chartData.latest_price ? chartData.latest_price.toLocaleString() + ' VND' : 'N/A'}</div>
                                </div>
                                <div>
                                    <div class="text-sm text-gray-600">Xu h∆∞·ªõng</div>
                                    <div class="text-lg font-bold ${trendColor}">${trendIcon} ${chartData.price_trend === 'increasing' ? 'TƒÉng' : chartData.price_trend === 'decreasing' ? 'Gi·∫£m' : '·ªîn ƒë·ªãnh'}</div>
                                </div>
                                <div>
                                    <div class="text-sm text-gray-600">Thay ƒë·ªïi</div>
                                    <div class="text-lg font-bold ${chartData.price_change >= 0 ? 'text-red-600' : 'text-green-600'}">
                                        ${chartData.price_change >= 0 ? '+' : ''}${chartData.price_change ? chartData.price_change.toLocaleString() : '0'} VND
                                    </div>
                                </div>
                                <div>
                                    <div class="text-sm text-gray-600">S·ªë b·∫£n ghi</div>
                                    <div class="text-lg font-bold">${chartData.total_records}</div>
                                </div>
                            </div>
                        </div>`;
                        
                        // Add chart container
                        html += `
                        <div class="mb-6">
                            <h4 class="text-lg font-semibold mb-3">Bi·ªÉu ƒë·ªì gi√° theo th·ªùi gian</h4>
                            <div class="relative">
                                <canvas id="priceChart" width="400" height="200"></canvas>
                            </div>
                        </div>`;
                    }
                    
                    // Show detailed history
                    if (data.price_history && data.price_history.length > 0) {
                        html += `
                        <div>
                            <h4 class="text-lg font-semibold mb-3">L·ªãch s·ª≠ chi ti·∫øt</h4>
                            <div class="overflow-x-auto">
                                <table class="min-w-full text-sm">
                                    <thead class="bg-gray-100">
                                        <tr>
                                            <th class="px-4 py-2 text-left">Th·ªùi gian</th>
                                            <th class="px-4 py-2 text-left">T√™n s·∫£n ph·∫©m</th>
                                            <th class="px-4 py-2 text-right">Gi√°</th>
                                        </tr>
                                    </thead>
                                    <tbody>`;
                        
                        data.price_history.reverse().forEach(log => {
                            const date = new Date(log.timestamp);
                            const formattedDate = date.toLocaleDateString('vi-VN') + ' ' + date.toLocaleTimeString('vi-VN');
                            html += `
                                <tr class="border-b">
                                    <td class="px-4 py-2">${formattedDate}</td>
                                    <td class="px-4 py-2">${log.name || 'N/A'}</td>
                                    <td class="px-4 py-2 text-right font-mono">${log.price ? log.price.toLocaleString() + ' VND' : 'N/A'}</td>
                                </tr>`;
                        });
                        
                        html += `
                                    </tbody>
                                </table>
                            </div>
                        </div>`;
                    } else {
                        html += '<div class="text-center py-10 text-gray-500">Ch∆∞a c√≥ l·ªãch s·ª≠ gi√° n√†o.</div>';
                    }
                    
                    container.innerHTML = html;
                    
                    // Create chart if data exists
                    if (chartData && chartData.labels && chartData.labels.length > 0) {
                        setTimeout(() => {
                            createPriceChart(chartData);
                        }, 100);
                    }
                })
                .catch(function (error) {
                    console.error('Error loading price history:', error);
                    document.getElementById('priceHistoryContent').innerHTML = '<div class="text-center py-10 text-red-500">L·ªói khi t·∫£i l·ªãch s·ª≠ gi√°.</div>';
                });
        }

        function createPriceChart(chartData) {
            const ctx = document.getElementById('priceChart');
            if (!ctx) return;
            
            // Destroy existing chart if it exists
            if (window.priceChartInstance) {
                window.priceChartInstance.destroy();
            }
            
            window.priceChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: chartData.labels,
                    datasets: [{
                        label: 'Gi√° (VND)',
                        data: chartData.prices,
                        borderColor: 'rgb(59, 130, 246)',
                        backgroundColor: 'rgba(59, 130, 246, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.1
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `Gi√°: ${context.parsed.y.toLocaleString()} VND`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: false,
                            ticks: {
                                callback: function(value) {
                                    return value.toLocaleString() + ' VND';
                                }
                            }
                        },
                        x: {
                            ticks: {
                                maxTicksLimit: 10
                            }
                        }
                    }
                }
            });
        }

        function selectProduct(productId, row) {
            // Check if this row is already selected
            const isAlreadySelected = selectedProductId === productId;
            
            // If clicking on the already selected product, just close it
            if (isAlreadySelected) {
                // Remove active styling from the row
                if (row) {
                    row.classList.remove('bg-blue-100');
                    row.classList.add('hover:bg-blue-50');
                }
                
                // Hide the enemy container for this product
                const enemyContainer = document.getElementById(`enemyContainer-${productId}`);
                if (enemyContainer) {
                    enemyContainer.classList.add('hidden');
                }
                
                // Clear selection and log display
                selectedProductId = null;
                selectedEnemyId = null;
                document.getElementById('logsContainer').innerHTML = '';
                return;
            }
            
            // Remove active styling from all rows
            document.querySelectorAll('.product-row').forEach(r => {
                r.classList.remove('bg-blue-100');
                r.classList.add('hover:bg-blue-50');
            });
            
            // Hide all enemy containers
            document.querySelectorAll('.enemy-container').forEach(container => {
                container.classList.add('hidden');
            });
            
            // Set this product as selected
            selectedProductId = productId;
            // Clear any previously selected enemy
            selectedEnemyId = null;
            
            // Add active styling to the clicked row
            if (row) {
                row.classList.add('bg-blue-100');
                row.classList.remove('hover:bg-blue-50');
            }
            
            // Show and load enemies for this product
            const enemyContainer = document.getElementById(`enemyContainer-${productId}`);
            if (enemyContainer) {
                enemyContainer.classList.remove('hidden');
                const enemyContent = document.getElementById(`enemyContent-${productId}`);
                if (enemyContent) {
                    loadEnemiesIntoContainer(productId, enemyContent);
                }
            }
            
            document.getElementById('logsContainer').innerHTML = '';
        }

        function loadEnemiesIntoContainer(productId, container) {
            container.innerHTML = '<div class="text-center py-5"><span class="text-gray-500">‚è≥ ƒêang t·∫£i d·ªØ li·ªáu ƒë·ªëi th·ªß...</span></div>';
            
            // First get the product details to show product name
            axios.get(`/api/product/${productId}`)
                .then(function(productResponse) {
                    const product = productResponse.data;
                    
                    // Then get the enemy products
                    return axios.get(`/api/product-crawls?prod_id=${productId}`)
                        .then(function(response) {
                            const crawls = response.data || [];
                            let html = `<div class='mb-2 flex justify-between items-center'>
                                <h3 class='font-bold text-lg'>S·∫£n ph·∫©m ƒë·ªëi th·ªß</h3>
                                <div class="flex space-x-2">
                                    <button onclick="crawlAllEnemies(${productId});event.stopPropagation();" class="bg-blue-600 text-white px-3 py-1 rounded" id="crawlAllButton-${productId}">üîÑ Crawl All</button>
                                    <button onclick="openEnemyModal(${productId});event.stopPropagation();" class="bg-green-600 text-white px-3 py-1 rounded">‚ûï Th√™m ƒë·ªëi th·ªß</button>
                                </div>
                            </div>`;
                            
                            if (!crawls || crawls.length === 0) {
                                html += '<div class="text-center py-4 text-gray-500 bg-gray-50 rounded border border-gray-200">Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m ƒë·ªëi th·ªß n√†o. H√£y th√™m m·ªõi!</div>';
                            } else {
                                html += `<table class="min-w-full text-sm text-left text-gray-700">
                                <thead class="bg-gray-100">
                                    <tr>
                                        <th>T√™n s·∫£n ph·∫©m</th>
                                        <th>ƒê·ªëi th·ªß</th>
                                        <th>Gi√° m·ªõi nh·∫•t</th>
                                        <th class="text-center">H√†nh ƒë·ªông</th>
                                    </tr>
                                </thead>
                                <tbody>`;
                                
                                // Create an array of promises to fetch latest price for each crawl
                                const pricePromises = crawls.map(crawl => {
                                    return axios.get(`/api/product-crawl-logs?product_crawl_id=${crawl.id}`)
                                        .then(logResponse => {
                                            const logs = logResponse.data;
                                            // Sort logs by timestamp to get the latest
                                            logs.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                                            return {
                                                crawlId: crawl.id,
                                                latestPrice: logs.length > 0 ? logs[0].price : null,
                                                latestName: logs.length > 0 ? logs[0].name : null
                                            };
                                        })
                                        .catch(() => {
                                            return { 
                                                crawlId: crawl.id,
                                                latestPrice: null,
                                                latestName: null
                                            };
                                        });
                                });
                                
                                // Wait for all price data to be fetched
                                Promise.all(pricePromises)
                                    .then(priceData => {
                                        // Create a map for quick lookup
                                        const priceMap = {};
                                        priceData.forEach(data => {
                                            priceMap[data.crawlId] = {
                                                price: data.latestPrice,
                                                name: data.latestName
                                            };
                                        });
                                        
                                        // Calculate price statistics
                                        const validPrices = priceData
                                            .map(data => data.latestPrice)
                                            .filter(price => price !== null && price !== undefined && price > 0);
                                        
                                        let priceStatsHtml = '';
                                        if (validPrices.length > 0) {
                                            const highestPrice = Math.max(...validPrices);
                                            const lowestPrice = Math.min(...validPrices);
                                            const avgPrice = validPrices.reduce((sum, price) => sum + price, 0) / validPrices.length;
                                            
                                            // Get original product price for comparison
                                            const originalPrice = product.cur_price || product.org_price;
                                            
                                            // Helper function to get color class based on comparison with original
                                            const getPriceColorClass = (price, original) => {
                                                if (!original || original === 0) return 'text-gray-600';
                                                return price < original ? 'text-green-600' : 'text-red-600';
                                            };
                                            
                                            priceStatsHtml = `
                                            <div class="bg-blue-50 p-3 rounded-lg mb-3 border border-blue-200">
                                                <h4 class="font-semibold text-blue-800 mb-2">üìä Th·ªëng k√™ gi√° ƒë·ªëi th·ªß</h4>
                                                <div class="grid grid-cols-3 gap-4 text-sm">
                                                    <div class="text-center">
                                                        <div class="text-gray-600">Gi√° cao nh·∫•t</div>
                                                        <div class="font-bold ${getPriceColorClass(highestPrice, originalPrice)}">
                                                            ${highestPrice.toLocaleString()} VND
                                                        </div>
                                                    </div>
                                                    <div class="text-center">
                                                        <div class="text-gray-600">Gi√° th·∫•p nh·∫•t</div>
                                                        <div class="font-bold ${getPriceColorClass(lowestPrice, originalPrice)}">
                                                            ${lowestPrice.toLocaleString()} VND
                                                        </div>
                                                    </div>
                                                    <div class="text-center">
                                                        <div class="text-gray-600">Gi√° trung b√¨nh</div>
                                                        <div class="font-bold ${getPriceColorClass(avgPrice, originalPrice)}">
                                                            ${Math.round(avgPrice).toLocaleString()} VND
                                                        </div>
                                                    </div>
                                                </div>
                                                ${originalPrice ? `
                                                <div class="mt-2 text-xs text-gray-600 text-center">
                                                    So v·ªõi gi√° g·ªëc: ${originalPrice.toLocaleString()} VND 
                                                    (<span class="text-green-600">Xanh = Th·∫•p h∆°n</span>, <span class="text-red-600">ƒê·ªè = Cao h∆°n</span>)
                                                </div>
                                                ` : ''}
                                            </div>`;
                                        }
                                        
                                        html += priceStatsHtml;
                                        
                                        // Now build the table with the price data
                                        crawls.forEach(crawl => {
                                            const priceInfo = priceMap[crawl.id] || { price: null, name: null };
                                            const displayName = priceInfo.name || product.name || "S·∫£n ph·∫©m";
                                            const displayPrice = priceInfo.price ? `${priceInfo.price.toLocaleString()} VND` : 'Ch∆∞a c√≥ gi√°';
                                            
                                            // Color code the price cell based on comparison with original
                                            const originalPrice = product.cur_price || product.org_price;
                                            let priceColorClass = '';
                                            if (priceInfo.price && originalPrice) {
                                                priceColorClass = priceInfo.price < originalPrice ? 'text-green-600 font-bold' : 'text-red-600 font-bold';
                                            }
                                            
                                            html += `<tr class="cursor-pointer hover:bg-blue-50 enemy-row" data-enemy-id="${crawl.id}" onclick="selectEnemy(${crawl.id}, this)">
                                                <td>
                                                    <a href="${crawl.link}" target="_blank" class="text-blue-600 hover:underline" onclick="event.stopPropagation()">${displayName}</a>
                                                </td>
                                                <td>${crawl.enemy ? crawl.enemy.name : ''}</td>
                                                <td class="${priceColorClass}">${displayPrice}</td>
                                                <td class="text-center space-x-1">
                                                    <button onclick="event.stopPropagation(); openEditEnemyModal(${productId},${crawl.id},'${crawl.link}')" class="bg-yellow-400 text-white px-2 py-1 rounded">‚úèÔ∏è</button>
                                                    <button onclick="event.stopPropagation(); deleteEnemy(${productId},${crawl.id})" class="bg-red-500 text-white px-2 py-1 rounded">üóëÔ∏è</button>
                                                    <button onclick="event.stopPropagation(); crawlEnemy(${crawl.id})" class="bg-blue-600 text-white px-2 py-1 rounded">üîÑ Crawl</button>
                                                    <button onclick="event.stopPropagation(); openPriceHistoryModal(${crawl.id})" class="bg-purple-600 text-white px-2 py-1 rounded">üìà L·ªãch s·ª≠</button>
                                                </td>
                                            </tr>`;
                                        });
                                        
                                        html += '</tbody></table>';
                                        container.innerHTML = html;
                                    });
                            }
                        });
                })
                .catch(function (error) {
                    console.error('Error loading enemy products:', error);
                    
                    // Check if the error is a 404 Not Found (meaning no products found)
                    if (error.response && error.response.status === 404) {
                        container.innerHTML = '<div class="text-center py-4 text-gray-500 bg-gray-50 rounded border border-gray-200">Kh√¥ng t√¨m th·∫•y s·∫£n ph·∫©m ƒë·ªëi th·ªß n√†o. H√£y th√™m m·ªõi!</div>';
                    } else {
                        container.innerHTML = '<div class="text-center py-5 text-red-500">L·ªói khi t·∫£i s·∫£n ph·∫©m ƒë·ªëi th·ªß.</div>';
                    }
                });
        }
        
        // Keep this function for backward compatibility or redirect to the new function
        function loadEnemies(productId) {
            const enemiesContainer = document.getElementById('enemiesContainer');
            enemiesContainer.innerHTML = '';
            
            // Just in case this function is still being called from some places
            const enemyContent = document.getElementById(`enemyContent-${productId}`);
            if (enemyContent) {
                loadEnemiesIntoContainer(productId, enemyContent);
            }
        }

        function selectEnemy(enemyCrawlId, row) {
            // Check if this enemy is already selected
            const isAlreadySelected = selectedEnemyId === enemyCrawlId;
            
            // If already selected, close it
            if (isAlreadySelected) {
                // Remove active styling
                if (row) {
                    row.classList.remove('bg-blue-100');
                    row.classList.add('hover:bg-blue-50');
                }
                
                // Remove log container if exists
                const logContainer = document.querySelector(`.log-container[data-enemy-id="${enemyCrawlId}"]`);
                if (logContainer) {
                    logContainer.remove();
                }
                
                // Clear logs display
                document.getElementById('logsContainer').innerHTML = '';
                selectedEnemyId = null;
                return;
            }
            
            // Set as selected enemy
            selectedEnemyId = enemyCrawlId;
            
            // Find the product this enemy belongs to
            if (selectedProductId) {
                // Remove active styling from all enemy rows
                document.querySelectorAll('.enemy-row').forEach(r => {
                    r.classList.remove('bg-blue-100');
                    r.classList.add('hover:bg-blue-50');
                });
                
                // Add active styling to this row
                if (row) {
                    row.classList.add('bg-blue-100');
                    row.classList.remove('hover:bg-blue-50');
                }
                
                // Remove all existing log containers
                const allLogContainers = document.querySelectorAll('.log-container');
                allLogContainers.forEach(container => {
                    container.remove();
                });
                
                // Insert new log container
                const logRow = document.createElement('tr');
                logRow.className = 'log-container';
                logRow.setAttribute('data-enemy-id', enemyCrawlId);
                logRow.innerHTML = `<td colspan="3" class="p-0">
                    <div class="bg-blue-50 p-3 border-l-4 border-blue-300">
                        <div id="logs-${enemyCrawlId}" class="py-2">
                            <div class="text-center">‚è≥ ƒêang t·∫£i l·ªãch s·ª≠ crawl...</div>
                        </div>
                    </div>
                </td>`;
                
                // Insert after enemy row
                if (row) {
                    row.parentNode.insertBefore(logRow, row.nextSibling);
                }
                
                // Load logs
                const logsContainer = document.getElementById(`logs-${enemyCrawlId}`);
                if (logsContainer) {
                    loadLogs(enemyCrawlId, logsContainer);
                }
            }
        }

        function loadLogs(enemyCrawlId, container = null) {
            const logsContainer = container || document.getElementById(`logs-${enemyCrawlId}`);
            
            if (!logsContainer) {
                // If we don't have a container, use the original logs container
                document.getElementById('logsContainer').innerHTML = '<div class="text-center py-5"><span class="text-gray-500">‚è≥ ƒêang t·∫£i l·ªãch s·ª≠ crawl...</span></div>';
            }
            
            axios.get(`/api/product-crawl-logs?product_crawl_id=${enemyCrawlId}`)
                .then(function (response) {
                    const logs = response.data;
                    let html = `<div class='mb-2 font-bold text-lg'>L·ªãch s·ª≠ crawl</div>`;
                    if (!logs.length) {
                        html += '<div class="text-gray-500">Ch∆∞a c√≥ l·ªãch s·ª≠ crawl.</div>';
                    } else {
                        html += '<ul class="mb-2">';
                        logs.forEach(log => {
                            html += `<li class="mb-1">${log.timestamp}: ${log.price || 'N/A'} (${log.name || ''})</li>`;
                        });
                        html += '</ul>';
                    }
                    
                    if (logsContainer) {
                        logsContainer.innerHTML = html;
                    } else {
                        document.getElementById('logsContainer').innerHTML = html;
                    }
                })
                .catch(function (error) {
                    const errorHtml = '<div class="text-center py-3 text-red-500">L·ªói khi t·∫£i l·ªãch s·ª≠ crawl.</div>';
                    
                    if (logsContainer) {
                        logsContainer.innerHTML = errorHtml;
                    } else {
                        document.getElementById('logsContainer').innerHTML = errorHtml;
                    }
                });
        }

        // CRUD for enemy products
        function openEnemyModal(productId) {
            document.getElementById('addEnemyModal').classList.remove('hidden');
            document.getElementById('addEnemyModal').classList.add('flex');
            document.getElementById('currentProductId').value = productId;
            document.getElementById('editEnemyId').value = '';
            document.getElementById('enemyLink').value = '';
            document.getElementById('enemyModalTitle').innerText = 'Th√™m s·∫£n ph·∫©m ƒë·ªëi th·ªß';
            document.getElementById('saveEnemyBtn').innerText = 'üíæ L∆∞u ƒë·ªëi th·ªß';
            document.getElementById('autoDetectStatus').innerHTML = '';
            loadEnemyDropdown();
        }

        function openEditEnemyModal(productId, enemyId, link) {
            document.getElementById('addEnemyModal').classList.remove('hidden');
            document.getElementById('addEnemyModal').classList.add('flex');
            document.getElementById('currentProductId').value = productId;
            document.getElementById('editEnemyId').value = enemyId;
            document.getElementById('enemyLink').value = link;
            document.getElementById('enemyModalTitle').innerText = 'Ch·ªânh s·ª≠a s·∫£n ph·∫©m ƒë·ªëi th·ªß';
            document.getElementById('saveEnemyBtn').innerText = 'üíæ L∆∞u ch·ªânh s·ª≠a';
            document.getElementById('autoDetectStatus').innerHTML = '';
            loadEnemyDropdown();
            
            // Auto-detect when editing to show the current association
            if (link) {
                detectEnemyFromLink(link, () => {});
            }
        }

        function loadEnemyDropdown() {
            const select = document.getElementById('enemySelect');
            select.innerHTML = '<option value="">-- T·ª± ƒë·ªông ph√°t hi·ªán t·ª´ domain --</option>';
            axios.get('/api/enemies/')
                .then(function (response) {
                    response.data.forEach(enemy => {
                        select.innerHTML += `<option value="${enemy.id}">${enemy.name} (${enemy.domain})</option>`;
                    });
                });
        }

        function addOrEditEnemyLink() {
            const productId = document.getElementById('currentProductId').value;
            const enemyId = document.getElementById('editEnemyId').value;
            const link = document.getElementById('enemyLink').value;
            const enemy_id = document.getElementById('enemySelect').value;
            
            if (!link) {
                alert('B·∫°n ph·∫£i nh·∫≠p link s·∫£n ph·∫©m ƒë·ªëi th·ªß!');
                return;
            }
            
            // If enemy not selected, detect from link domain and create if needed
            if (!enemy_id) {
                detectEnemyFromLink(link, (detectedEnemyId) => {
                    if (detectedEnemyId) {
                        saveEnemyLink(productId, enemyId, link, detectedEnemyId);
                    } else {
                        alert('Kh√¥ng th·ªÉ x√°c ƒë·ªãnh ƒë·ªëi th·ªß t·ª´ domain. Vui l√≤ng th·ª≠ l·∫°i ho·∫∑c ch·ªçn ƒë·ªëi th·ªß th·ªß c√¥ng.');
                    }
                });
            } else {
                saveEnemyLink(productId, enemyId, link, parseInt(enemy_id));
            }
        }
        
        function detectEnemyFromLink(link, callback) {
            // Show detection status
            const saveBtn = document.getElementById('saveEnemyBtn');
            const originalBtnText = saveBtn.innerText;
            saveBtn.innerText = 'üîç ƒêang ph√°t hi·ªán ƒë·ªëi th·ªß...';
            saveBtn.disabled = true;
            
            try {
                // Extract domain from the hostname (clickbuy.com.vn from https://clickbuy.com.vn/...)
                const url = new URL(link);
                const hostname = url.hostname;
                // Get the domain which is the first part of the hostname
                const domain = hostname.split('.')[0];
                
                // Use the API to search for enemy by domain
                axios.get(`/api/enemies/by-domain?domain=${encodeURIComponent(domain)}&auto_create=true`)
                    .then(response => {
                        const matchedEnemy = response.data;
                        
                        if (response.status === 201) {
                            // Enemy was auto-created by the API
                            // Update the dropdown with the new enemy
                            const select = document.getElementById('enemySelect');
                            select.innerHTML += `<option value="${matchedEnemy.id}">${matchedEnemy.name} (${matchedEnemy.domain})</option>`;
                            select.value = matchedEnemy.id;
                            
                            document.getElementById('autoDetectStatus').innerHTML = `
                                <span class="text-green-600">‚úì T·ª± ƒë·ªông t·∫°o ƒë·ªëi th·ªß m·ªõi: ${matchedEnemy.name}</span>`;
                            callback(matchedEnemy.id);
                            
                            saveBtn.innerText = originalBtnText;
                            saveBtn.disabled = false;
                            return;
                        } else if (response.status === 204) {
                            // Handle "no content" status - no enemy found and couldn't be auto-created
                            document.getElementById('autoDetectStatus').innerHTML = `<span class="text-blue-600">‚è≥ Kh√¥ng t√¨m th·∫•y ƒë·ªëi th·ªß, ƒëang t·ª± ƒë·ªông t·∫°o m·ªõi...</span>`;
                            createNewEnemy(domain, callback, saveBtn, originalBtnText);
                            return;
                        }
                        
                        // We found a match using the API (status 200)
                        if (matchedEnemy && matchedEnemy.id && matchedEnemy.name) {
                            document.getElementById('enemySelect').value = matchedEnemy.id;
                            document.getElementById('autoDetectStatus').innerHTML = `<span class="text-green-600">‚úì ƒê√£ ph√°t hi·ªán: ${matchedEnemy.name}</span>`;
                            callback(matchedEnemy.id);
                        } else {
                            // Fallback: Create a new enemy if we somehow got here with invalid data
                            document.getElementById('autoDetectStatus').innerHTML = `<span class="text-blue-600">‚è≥ Kh√¥ng t√¨m th·∫•y ƒë·ªëi th·ªß, ƒëang t·ª± ƒë·ªông t·∫°o m·ªõi...</span>`;
                            createNewEnemy(domain, callback, saveBtn, originalBtnText);
                        }
                        
                        if (matchedEnemy && matchedEnemy.id) {
                            // Only restore button state if we found a match (otherwise done in the create callback)
                            saveBtn.innerText = originalBtnText;
                            saveBtn.disabled = false;
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching enemies:', error);
                        document.getElementById('autoDetectStatus').innerHTML = `<span class="text-red-600">‚úó L·ªói khi t√¨m ki·∫øm ƒë·ªëi th·ªß</span>`;
                        callback(null);
                        saveBtn.innerText = originalBtnText;
                        saveBtn.disabled = false;
                    });
            } catch (error) {
                console.error('Invalid URL:', error);
                document.getElementById('autoDetectStatus').innerHTML = `<span class="text-red-600">‚úó URL kh√¥ng h·ª£p l·ªá</span>`;
                callback(null);
                saveBtn.innerText = originalBtnText;
                saveBtn.disabled = false;
            }
        }
        
        // Function is now handled by the backend API
        function createNewEnemy(domain, callback, saveBtn, originalBtnText) {
            // Fallback function in case the API doesn't auto-create
            let enemyName;
            
            // Check if domain contains dots
            if (domain.includes('.')) {
                enemyName = domain.split('.')[0];
            } else {
                // If no dots, use the whole domain
                enemyName = domain;
            }
            
            // Capitalize the first letter
            enemyName = enemyName.charAt(0).toUpperCase() + enemyName.slice(1);
            
            // Create new enemy manually as a fallback
            axios.post('/api/enemies/', {
                name: enemyName,
                domain: domain
            })
            .then(createResponse => {
                const newEnemy = createResponse.data;
                // Update the dropdown
                const select = document.getElementById('enemySelect');
                select.innerHTML += `<option value="${newEnemy.id}">${newEnemy.name} (${newEnemy.domain})</option>`;
                select.value = newEnemy.id;
                
                document.getElementById('autoDetectStatus').innerHTML = `
                    <span class="text-green-600">‚úì T·ª± ƒë·ªông t·∫°o ƒë·ªëi th·ªß m·ªõi: ${newEnemy.name}</span>`;
                callback(newEnemy.id);
            })
            .catch(createError => {
                console.error('Error creating new enemy:', createError);
                document.getElementById('autoDetectStatus').innerHTML = `
                    <span class="text-red-600">‚úó Kh√¥ng th·ªÉ t·∫°o ƒë·ªëi th·ªß m·ªõi. Vui l√≤ng ch·ªçn ƒë·ªëi th·ªß th·ªß c√¥ng.</span>`;
                callback(null);
            })
            .finally(() => {
                saveBtn.innerText = originalBtnText;
                saveBtn.disabled = false;
            });
        }
        
        function saveEnemyLink(productId, enemyId, link, enemy_id) {
            if (enemyId) {
                axios.put(`/api/product-crawls/${enemyId}`, { prod_id: productId, link, enemy_id: enemy_id })
                    .then(() => {
                        closeEnemyModal();
                        // Refresh enemies in the product container
                        const enemyContent = document.getElementById(`enemyContent-${productId}`);
                        if (enemyContent) {
                            loadEnemiesIntoContainer(productId, enemyContent);
                        }
                    })
                    .catch(() => alert('L·ªói khi c·∫≠p nh·∫≠t ƒë·ªëi th·ªß.'));
            } else {
                axios.post(`/api/product-crawls/`, { prod_id: productId, link, enemy_id: enemy_id })
                    .then(() => {
                        closeEnemyModal();
                        // Refresh enemies in the product container
                        const enemyContent = document.getElementById(`enemyContent-${productId}`);
                        if (enemyContent) {
                            loadEnemiesIntoContainer(productId, enemyContent);
                        }
                    })
                    .catch(() => alert('L·ªói khi th√™m ƒë·ªëi th·ªß.'));
            }
        }

        function deleteEnemy(productId, crawlId) {
            if (!confirm('B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a s·∫£n ph·∫©m ƒë·ªëi th·ªß n√†y?')) return;
            axios.delete(`/api/product-crawls/${crawlId}`)
                .then(() => {
                    // Refresh the enemies in the correct container
                    const enemyContent = document.getElementById(`enemyContent-${productId}`);
                    if (enemyContent) {
                        loadEnemiesIntoContainer(productId, enemyContent);
                    }
                    document.getElementById('logsContainer').innerHTML = '';
                })
                .catch(() => alert('L·ªói khi x√≥a ƒë·ªëi th·ªß.'));
        }

        function closeEnemyModal() {
            document.getElementById('addEnemyModal').classList.add('hidden');
            document.getElementById('addEnemyModal').classList.remove('flex');
        }
        
        function onEnemyLinkChange(link) {
            // Only process if link is not empty and looks like a valid URL
            if (link && (link.startsWith('http://') || link.startsWith('https://'))) {
                document.getElementById('autoDetectStatus').innerHTML = `<span class="text-gray-600">üîç ƒêang ph√°t hi·ªán ƒë·ªëi th·ªß...</span>`;
                detectEnemyFromLink(link, () => {});
            } else {
                document.getElementById('autoDetectStatus').innerHTML = '';
            }
        }

        // CRUD for products (update endpoints)
        function addOrEditProduct() {
            const id = document.getElementById('editProductId').value;
            
            // Handle empty price values
            let orgPrice = document.getElementById('productOrigPrice').value;
            let curPrice = document.getElementById('productCurPrice').value;
            
            // Convert empty strings to null
            if (orgPrice === '') orgPrice = null;
            if (curPrice === '') curPrice = null;
            
            const productData = {
                name: document.getElementById('productName').value,
                sku: document.getElementById('productSKU').value,
                link: document.getElementById('productLink').value,
                org_price: orgPrice,
                cur_price: curPrice
            };

            if (id) {
                // Edit product
                axios.put(`/api/product/${id}`, productData)
                    .then(function () {
                        closeAddProductModal();
                        loadProducts();
                    })
                    .catch(function (error) {
                        console.error('Error updating product:', error);
                        alert('L·ªói khi c·∫≠p nh·∫≠t s·∫£n ph·∫©m: ' + (error.response?.data?.message || error.message));
                    });
            } else {
                // Add new product
                axios.post('/api/product/', productData)
                    .then(function () {
                        closeAddProductModal();
                        loadProducts();
                    })
                    .catch(function (error) {
                        console.error('Error adding product:', error);
                        alert('L·ªói khi th√™m s·∫£n ph·∫©m: ' + (error.response?.data?.message || error.message));
                    });
            }
        }

        function openEditProductModal(productId) {
            axios.get(`/api/product/${productId}`)
                .then(function (response) {
                    const product = response.data;
                    document.getElementById('addProductModal').classList.remove('hidden');
                    document.getElementById('addProductModal').classList.add('flex');
                    document.getElementById('productModalTitle').innerText = 'Ch·ªânh s·ª≠a s·∫£n ph·∫©m g·ªëc';
                    document.getElementById('editProductId').value = product.id;
                    document.getElementById('productName').value = product.name;
                    document.getElementById('productSKU').value = product.sku;
                    document.getElementById('productLink').value = product.link;
                    document.getElementById('productOrigPrice').value = product.org_price;
                    document.getElementById('productCurPrice').value = product.cur_price;
                    document.getElementById('saveProductBtn').innerText = 'üíæ L∆∞u ch·ªânh s·ª≠a';
                    document.getElementById('detectProductStatus').innerHTML = '';
                })
                .catch(function (error) {
                    console.error('Error fetching product details:', error);
                });
        }

        function deleteProduct(productId) {
            if (!confirm('B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a s·∫£n ph·∫©m n√†y?')) return;
            axios.delete(`/api/product/${productId}`)
                .then(function () {
                    loadProducts();
                })
                .catch(function (error) {
                    console.error('Error deleting product:', error);
                });
        }

        // Crawl logs for a product
        function showLogs(productId) {
            axios.get(`/api/product/${productId}/logs`)
                .then(function (response) {
                    const logs = response.data;
                    let html = `<div class='p-4'><h3 class='font-bold mb-2'>L·ªãch s·ª≠ crawl</h3>`;
                    if (!logs.length) {
                        html += '<div class="text-gray-500">Ch∆∞a c√≥ l·ªãch s·ª≠ crawl.</div>';
                    } else {
                        html += '<ul class="mb-2">';
                        logs.forEach(log => {
                            html += `<li class="mb-1">${log.timestamp}: ${log.price || 'N/A'} (${log.status || ''})</li>`;
                        });
                        html += '</ul>';
                    }
                    html += `<button onclick="closePopup()" class="bg-gray-400 text-white px-3 py-1 rounded">ƒê√≥ng</button></div>`;
                    showPopup(html);
                })
                .catch(function (error) {
                    alert('L·ªói khi t·∫£i l·ªãch s·ª≠ crawl');
                });
        }

        // Simple popup for enemies/logs
        function showPopup(html) {
            let popup = document.getElementById('popupModal');
            if (!popup) {
                popup = document.createElement('div');
                popup.id = 'popupModal';
                popup.className = 'fixed inset-0 bg-black bg-opacity-40 flex items-center justify-center z-50';
                popup.innerHTML = `<div class='bg-white rounded-lg p-6 w-full max-w-lg shadow-xl'>${html}</div>`;
                document.body.appendChild(popup);
            } else {
                popup.innerHTML = `<div class='bg-white rounded-lg p-6 w-full max-w-lg shadow-xl'>${html}</div>`;
                popup.classList.remove('hidden');
                popup.classList.add('flex');
            }
        }
        function closePopup() {
            let popup = document.getElementById('popupModal');
            if (popup) popup.classList.add('hidden');
        }

        function closeAddProductModal() {
            document.getElementById('addProductModal').classList.add('hidden');
            document.getElementById('addProductModal').classList.remove('flex');
        }

        function refreshData() {
            // Reset selection state
            selectedProductId = null;
            selectedEnemyId = null;
            
            // Reset pagination and search state
            currentPage = 1;
            currentSearch = '';
            document.getElementById('searchInput').value = '';
            
            // Clear display containers
            document.getElementById('enemiesContainer').innerHTML = '';
            document.getElementById('logsContainer').innerHTML = '';
            
            // Reload products with pagination
            loadProducts(currentPage, currentSearch);
        }

        // Implement product and enemy crawling functions
        function crawlProduct(productId) {
            // First get the product details to access the link
            axios.get(`/api/product/${productId}`)
                .then(function(response) {
                    const product = response.data;
                    if (!product.link) {
                        alert('S·∫£n ph·∫©m n√†y kh√¥ng c√≥ li√™n k·∫øt ƒë·ªÉ crawl!');
                        return;
                    }
                    
                    // Show crawling status for product
                    const productRow = document.querySelector(`.product-row[data-product-id="${productId}"]`);
                    if (productRow) {
                        const cells = productRow.querySelectorAll('td');
                        if (cells.length > 0) {
                            const actionBtns = cells[cells.length - 1].querySelectorAll('button');
                            if (actionBtns.length >= 3) {
                                const crawlBtn = actionBtns[2];
                                const originalText = crawlBtn.innerHTML;
                                crawlBtn.innerHTML = '‚è≥ ƒêang crawl...';
                                crawlBtn.disabled = true;
                                
                                // Call the backend to initiate crawling
                                axios.post(`/api/product/${productId}/crawl`)
                                    .then(function(crawlResponse) {
                                        // Update current price if available in response
                                        if (crawlResponse.data && crawlResponse.data.cur_price) {
                                            cells[4].innerText = crawlResponse.data.cur_price;
                                        }
                                        crawlBtn.innerHTML = '‚úì Ho√†n t·∫•t';
                                        setTimeout(() => {
                                            crawlBtn.innerHTML = originalText;
                                            crawlBtn.disabled = false;
                                        }, 2000);
                                    })
                                    .catch(function(error) {
                                        console.error('Error crawling product:', error);
                                        crawlBtn.innerHTML = '‚úó L·ªói';
                                        setTimeout(() => {
                                            crawlBtn.innerHTML = originalText;
                                            crawlBtn.disabled = false;
                                        }, 2000);
                                        alert('L·ªói khi crawl s·∫£n ph·∫©m. Vui l√≤ng th·ª≠ l·∫°i sau.');
                                    });
                            }
                        }
                    }
                })
                .catch(function(error) {
                    console.error('Error getting product details:', error);
                    alert('L·ªói khi l·∫•y th√¥ng tin s·∫£n ph·∫©m.');
                });
        }

        function crawlEnemy(enemyCrawlId) {
            // First, we need to find which product this enemy belongs to
            let productId = selectedProductId;
            let crawlBtn = null;
            
            // Find the enemy's row and crawl button in its product container
            if (productId) {
                const enemyContent = document.getElementById(`enemyContent-${productId}`);
                if (enemyContent) {
                    const enemyRows = enemyContent.querySelectorAll('tr');
                    
                    // Find the row corresponding to this enemy and get its crawl button
                    for (let i = 0; i < enemyRows.length; i++) {
                        const row = enemyRows[i];
                        if (row.onclick && row.onclick.toString().includes(enemyCrawlId)) {
                            const cells = row.querySelectorAll('td');
                            if (cells.length > 0) {
                                const actionBtns = cells[cells.length - 1].querySelectorAll('button');
                                if (actionBtns.length >= 3) {
                                    crawlBtn = actionBtns[2];
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            
            if (crawlBtn) {
                const originalText = crawlBtn.innerHTML;
                crawlBtn.innerHTML = '‚è≥ ƒêang crawl...';
                crawlBtn.disabled = true;
                
                // Call the crawl endpoint with the enemy crawl ID
                axios.post(`/api/product-crawls/crawl-link`, { crawl_id: enemyCrawlId })
                    .then(function(response) {
                        crawlBtn.innerHTML = '‚úì Ho√†n t·∫•t';
                        setTimeout(() => {
                            crawlBtn.innerHTML = originalText;
                            crawlBtn.disabled = false;
                        }, 2000);
                        
                        // Reload the logs to show the latest crawl data
                        if (selectedEnemyId === enemyCrawlId) {
                            loadLogs(enemyCrawlId);
                        }
                    })
                    .catch(function(error) {
                        console.error('Error crawling enemy product:', error);
                        crawlBtn.innerHTML = '‚úó L·ªói';
                        setTimeout(() => {
                            crawlBtn.innerHTML = originalText;
                            crawlBtn.disabled = false;
                        }, 2000);
                        alert('L·ªói khi crawl s·∫£n ph·∫©m ƒë·ªëi th·ªß. Vui l√≤ng th·ª≠ l·∫°i sau.');
                    });
            } else {
                alert('Kh√¥ng th·ªÉ t√¨m th·∫•y n√∫t crawl cho s·∫£n ph·∫©m ƒë·ªëi th·ªß n√†y.');
            }
        }

        function crawlAllEnemies(productId) {
            const crawlAllBtn = document.getElementById(`crawlAllButton-${productId}`);
            const originalText = crawlAllBtn.innerHTML;
            crawlAllBtn.innerHTML = '‚è≥ ƒêang crawl t·∫•t c·∫£...';
            crawlAllBtn.disabled = true;
            
            // Get all enemies for this product
            axios.get(`/api/product-crawls?prod_id=${productId}`)
                .then(function(response) {
                    const crawls = response.data;
                    if (crawls.length === 0) {
                        crawlAllBtn.innerHTML = '‚ö†Ô∏è Kh√¥ng c√≥ ƒë·ªëi th·ªß';
                        setTimeout(() => {
                            crawlAllBtn.innerHTML = originalText;
                            crawlAllBtn.disabled = false;
                        }, 2000);
                        return;
                    }
                    
                    let completedCrawls = 0;
                    let failedCrawls = 0;
                    
                    // Function to update button text with progress
                    const updateProgress = () => {
                        crawlAllBtn.innerHTML = `‚è≥ ${completedCrawls}/${crawls.length}`;
                        if (completedCrawls + failedCrawls === crawls.length) {
                            if (failedCrawls > 0) {
                                crawlAllBtn.innerHTML = `‚úì ${completedCrawls}/${crawls.length} (${failedCrawls} l·ªói)`;
                            } else {
                                crawlAllBtn.innerHTML = `‚úì Ho√†n t·∫•t ${crawls.length}/${crawls.length}`;
                            }
                            setTimeout(() => {
                                crawlAllBtn.innerHTML = originalText;
                                crawlAllBtn.disabled = false;
                            }, 2000);
                            
                            // Reload enemies to refresh data
                            const enemyContent = document.getElementById(`enemyContent-${productId}`);
                            if (enemyContent) {
                                loadEnemiesIntoContainer(productId, enemyContent);
                            }
                            
                            // Reload logs if an enemy is selected
                            if (selectedEnemyId) {
                                loadLogs(selectedEnemyId);
                            }
                        }
                    }
                    
                    // Crawl each enemy product
                    crawls.forEach(crawl => {
                        axios.post(`/api/product-crawls/crawl-link`, { crawl_id: crawl.id })
                            .then(function() {
                                completedCrawls++;
                                updateProgress();
                            })
                            .catch(function() {
                                failedCrawls++;
                                updateProgress();
                            });
                    });
                })
                .catch(function(error) {
                    console.error('Error fetching enemies for crawling:', error);
                    crawlAllBtn.innerHTML = '‚úó L·ªói';
                    setTimeout(() => {
                        crawlAllBtn.innerHTML = originalText;
                        crawlAllBtn.disabled = false;
                    }, 2000);
                });
        }

        function detectProductInfo() {
            const link = document.getElementById('productLink').value;
            if (!link) {
                alert('Vui l√≤ng nh·∫≠p link s·∫£n ph·∫©m!');
                return;
            }
            
            // Show status
            const statusDiv = document.getElementById('detectProductStatus');
            statusDiv.innerHTML = '<span class="text-gray-600">‚è≥ ƒêang crawl th√¥ng tin s·∫£n ph·∫©m...</span>';
            
            // Disable crawl button
            const crawlBtn = document.querySelector('#addProductModal button[onclick="detectProductInfo()"]');
            const originalBtnText = crawlBtn.innerHTML;
            crawlBtn.innerHTML = '‚è≥ ƒêang crawl...';
            crawlBtn.disabled = true;
            
            // Call the extract-info endpoint
            axios.post('/api/product/extract-info', { link: link })
                .then(function(response) {
                    const data = response.data;
                    
                    // Update form fields with retrieved data
                    if (data.name) {
                        document.getElementById('productName').value = data.name;
                    }
                    
                    if (data.sku) {
                        document.getElementById('productSKU').value = data.sku;
                    }
                    
                    // Handle prices - make sure they're valid numbers
                    if (data.org_price !== null && data.org_price !== undefined) {
                        document.getElementById('productOrigPrice').value = data.org_price;
                    }
                    
                    if (data.cur_price !== null && data.cur_price !== undefined) {
                        document.getElementById('productCurPrice').value = data.cur_price;
                    }
                    
                    // Update status
                    statusDiv.innerHTML = '<span class="text-green-600">‚úì ƒê√£ l·∫•y th√¥ng tin s·∫£n ph·∫©m th√†nh c√¥ng!</span>';
                    
                    // Reset button
                    crawlBtn.innerHTML = originalBtnText;
                    crawlBtn.disabled = false;
                })
                .catch(function(error) {
                    console.error('Error detecting product info:', error);
                    statusDiv.innerHTML = 
                        '<span class="text-red-600">‚úó L·ªói khi l·∫•y th√¥ng tin s·∫£n ph·∫©m</span>';
                    crawlBtn.innerHTML = originalBtnText;
                    crawlBtn.disabled = false;
                });
        }
        
        function detectProductInfo() {
            const link = document.getElementById('productLink').value;
            if (!link) {
                alert('Vui l√≤ng nh·∫≠p link s·∫£n ph·∫©m tr∆∞·ªõc khi crawl!');
                return;
            }
            
            // Show status
            const statusDiv = document.getElementById('detectProductStatus');
            statusDiv.innerHTML = '<span class="text-gray-600">‚è≥ ƒêang crawl th√¥ng tin s·∫£n ph·∫©m...</span>';
            
            // Disable crawl button
            const crawlBtn = document.querySelector('#addProductModal button[onclick="detectProductInfo()"]');
            const originalText = crawlBtn.innerHTML;
            crawlBtn.innerHTML = '‚è≥ ƒêang crawl...';
            crawlBtn.disabled = true;
            
            // Call API to extract product info
            axios.post('/api/product/extract-info', { link: link })
                .then(function(response) {
                    const productInfo = response.data;
                    
                    // Update form fields with crawled data
                    if (productInfo.name) {
                        document.getElementById('productName').value = productInfo.name;
                    }
                    
                    if (productInfo.sku) {
                        document.getElementById('productSKU').value = productInfo.sku;
                    }
                    
                    if (productInfo.org_price) {
                        document.getElementById('productOrigPrice').value = productInfo.org_price;
                    }
                    
                    if (productInfo.cur_price) {
                        document.getElementById('productCurPrice').value = productInfo.cur_price;
                    }
                    
                    statusDiv.innerHTML = '<span class="text-green-600">‚úì Crawl th√†nh c√¥ng</span>';
                    crawlBtn.innerHTML = originalText;
                    crawlBtn.disabled = false;
                })
                .catch(function(error) {
                    console.error('Error extracting product info:', error);
                    statusDiv.innerHTML = '<span class="text-red-600">‚úó L·ªói khi crawl th√¥ng tin</span>';
                    crawlBtn.innerHTML = originalText;
                    crawlBtn.disabled = false;
                    alert('Kh√¥ng th·ªÉ crawl th√¥ng tin. Vui l√≤ng ki·ªÉm tra link ho·∫∑c th·ª≠ l·∫°i sau.');
                });
        }
        
        function onProductLinkChange(link) {
            // Reset status
            document.getElementById('detectProductStatus').innerHTML = '';
            
            // Auto crawl if link looks valid
            if (link && (link.startsWith('http://') || link.startsWith('https://'))) {
                detectProductInfo();
            }
        }
        
        function openAddProductModal() {
            document.getElementById('addProductModal').classList.remove('hidden');
            document.getElementById('addProductModal').classList.add('flex');
            document.getElementById('productModalTitle').innerText = 'Th√™m s·∫£n ph·∫©m g·ªëc';
            document.getElementById('editProductId').value = '';
            document.getElementById('productName').value = '';
            document.getElementById('productSKU').value = '';
            document.getElementById('productLink').value = '';
            document.getElementById('productOrigPrice').value = '';
            document.getElementById('productCurPrice').value = '';
            document.getElementById('saveProductBtn').innerText = 'üíæ L∆∞u s·∫£n ph·∫©m';
            document.getElementById('detectProductStatus').innerHTML = '';
        }
    </script>
</body>

</html>